============================================================================================================! The SQL Execution Order !=======================================================================================================================================

Step,      Clause,                  Purpose
1st,      FROM / JOIN            Determines the data source (the tables) and combines them (if necessary) to form the base result set. This is always the starting point.
2nd,      WHERE                  Filters the rows from the base result set before any grouping or aggregation.
3rd,      GROUP BY               Partitions the filtered rows into groups for aggregation.
4th,      HAVING                 Filters the groups created by GROUP BY (based on aggregate results).
5th,      SELECT                 Calculates aggregate functions and selects the final columns.
6th,      ORDER BY               Sorts the final result set.
7th,      LIMIT / OFFSET         Limits the number of rows returned.

=> Execution vs. Writing: The order above is the execution order. We write the query in a different order (e.g., SELECT first, FROM second).

==================================================================================================! SQL Query Execution: Logical Processing Order !============================================================================================================================================

=> This sequence explains how a database internally processes and executes a standard SQL query, focusing on how columns are handled.
=> Phase 1: Planning and Parsing (Reads the Whole Query)
  -> The database engine starts by reading the entire query to build an execution plan before fetching any data.
  -> Reads All Clauses: The engine identifies every table, column, and function used throughout the query (in the FROM, JOIN, ON, GROUP BY, and SELECT clauses).
  -> Column Inventory: It creates an inventory of ALL necessary columns. A column is necessary if it's used for:
    -> Joining tables (ON conditions).
    -> Filtering data (WHERE or HAVING conditions).
    -> Grouping results (GROUP BY).
    -> Calculations (SUM, AVG, ROUND).
    -> The final output (SELECT)
=> Phase 2: Data Acquisition and Transformation (The First Logical Steps): These steps create the working dataset that is acted upon by the rest of the query.
  -> Step 1: FROM and JOIN (Creates the Intermediate Table)
    -> Execution: This is the first logical step executed.
    -> Column Inclusion: The engine builds a single, wide intermediate table that contains ALL columns needed for the inventory created in Phase 1 (i.e., all columns from both tables, filtered by the ON clause).
    -> Filtering: The ON condition (e.g., U.purchase_date BETWEEN P.start_date AND P.end_date) is applied immediately to filter rows during the join process, ensuring only relevant records make it into the intermediate table.
  -> Step 2: GROUP BY (Aggregates Data)
    -> Execution: Takes the intermediate table from Step 1.
    -> Grouping: It bundles rows together based on the specified column (P.product_id).
  -> Step 3: SELECT Calculations (Calculates the Final Values)
    -> Execution: The aggregate functions (SUM, ROUND, COALESCE) are applied to the groups defined in Step 2. The weighted average is calculated here: SUM(Revenue) / SUM(Units).
=> Phase 3: Projection (The Final Output)
  -> Step 4: SELECT (Projects the Final Result)
    -> Execution: This is the last step.
    -> Column Filtering: The database discards all the intermediate columns used for joining, filtering, and internal calculation.
    -> Result: Only the columns explicitly listed in the final SELECT clause (product_id and the calculated average_price) are returned to the user.

==================================================================================================================! RULE !============================================================================================================================================

=> The Precise GROUP BY Rule:
  -> If your SELECT list contains ONLY aggregate functions OR ONLY non-aggregate functions, you DO NOT need a GROUP BY clause.
  -> If your SELECT list contains a mix of both aggregate functions and non-aggregate functions, you MUST include a GROUP BY clause. The non-aggregated columns define how the data should be partitioned for the calculation.
  -> Example with Internal working step: https://leetcode.com/problems/customer-who-visited-but-did-not-make-any-transactions/?envType=study-plan-v2&envId=top-sql-50

==================================================================================================================! The SQL JOIN TYPE !============================================================================================================================================

=> Self-Join & Cross Join
  -> The JOIN (Self-Join): In SQL, a JOIN is used to combine columns from two or more tables based on a related column between them. A Self-Join is simply a JOIN where a table is joined to itself.
  -> How the Self-Join Works Internally (The Cross Join Phase)
    -> Initialization and Aliasing: The database uses the FROM TableName w1 JOIN TableName w2 syntax to treat the single physical table as two temporary, separate tables: w1 (Table 1) and w2 (Table 2). This step allows you to reference columns from the same row using two different contexts (e.g., w1.Employee vs. w2.Manager).
    -> The Cartesian Product (The "Massive Table" Creation): The database engine takes every single row from the first aliased table (w1) and matches it with every single row from the second aliased table (w2).
      -> If the original table has N rows, the temporary internal table created at this stage will have N*N rows. This is the Cross Join Phase.
      -> Example: If you have 10 rows in your table, this temporary table will have 10*10 = 100 rows.
    -> The ON Clause Filtration (The Joining Condition): The database immediately applies the condition specified in the ON clause to the massive N*N result set.
      -> The ON clause acts as a filter, removing the vast majority of combinations and keeping only the meaningful pairs that satisfy the relationship you defined.
      -> Only the rows that logically belong together (e.g., today's temperature paired with yesterday's temperature(Sequential/Temporal: w2.Date = w1.Date + 1 Day)) remain for the final SELECT step.
    -> The Cross Join is a necessary internal step in a Self-Join. It guarantees that the engine considers every possible pairing before the ON clause condition filters the matches down to the specific relationship you need (e.g., employee to manager, or day to previous day).
  ->Example: https://leetcode.com/problems/rising-temperature/description/?envType=study-plan-v2&envId=top-sql-50

==================================================================================================================! MySQL Numeric Functions (Mathematical) !============================================================================================================================================
=> ABS(x) : Return the absolute non-negative value of x. Example: SELECT ABS(-10); (Result: 10)
=> ROUND(x, d): Rounds x to d decimal places. Example: SELECT ROUND(4.567, 2); (Result: 4.57)
=> CEIL(x): Returns the smallest integer greater than or equal to x (rounds up). Example: SELECT CEIL(5.1); (Result: 6)
=> FLOOR(x): Returns the largest integer less than or equal to x (rounds down). Example: SELECT FLOOR(5.9); (Result: 5)
=> MOD(N, M): Returns the remainder of N divided by M. (Same as N % M). Example: SELECT MOD(10, 3); (Result: 1)
=> POWER(x, y): Returns x raised to the power of y. Example: SELECT POWER(2, 3); (Result: 8)
=> SQRT(x): Returns the non-negative square root of x. Example: SELECT SQRT(9); (Result: 3)

==================================================================================================================! MySQL String Functions !============================================================================================================================================
=> CONCAT(s1, s2, ...): Joins two or more strings together. Example: SELECT CONCAT('Hello', ' ', 'World'); (Result: 'Hello World')
=> LENGTH(s): Returns the length of the string in bytes. Example: SELECT LENGTH('SQL'); (Result: 3)
=> CHAR_LENGTH(s): Returns the length of the string in characters. Example: SELECT CHAR_LENGTH('SQL'); (Result: 3)
=> SUBSTRING(s, start, len): Extracts a substring of length len starting at start. Example: SELECT SUBSTRING('Database', 4, 3); (Result: 'aba')
=> UPPER(s) / LOWER(s): Converts the string to uppercase / lowercase. Example: SELECT UPPER('test'); (Result: 'TEST')
=> TRIM(s): Removes leading and trailing spaces (or specified characters). Example: SELECT TRIM(' SQL '); (Result: 'SQL')
=> REPLACE(s, old, new): Replaces all occurrences of old string with new string in s. Example: SELECT REPLACE('cat', 'c', 'b'); (Result: 'bat')

==================================================================================================================! MySQL Date and Time Functions !============================================================================================================================================
=> NOW(): Returns the current date and time. Example: SELECT NOW(); (e.g., 2023-11-02 10:17:00)
=> CURDATE(): Returns the current date. Example: SELECT CURDATE(); (e.g., 2023-11-02)
=> YEAR(d) / MONTH(d) / DAY(d): Extracts the year, month, or day part from a date. Example: SELECT YEAR(CURDATE()); (e.g., 2023)
=> DATEDIFF(d1, d2): Returns the number of days between two dates. Example: SELECT DATEDIFF('2023-11-02', '2023-10-02'); (Result: 31)
=> DATE_ADD(d, INTERVAL val unit): Adds a time interval to a date. Example: SELECT DATE_ADD(CURDATE(), INTERVAL 1 WEEK);
=> DATE_FORMAT(d, format): Formats a date value as specified. Example: SELECT DATE_FORMAT(NOW(), '%Y/%m/%d');

==================================================================================================================! MySQL Aggregate Functions (Used with GROUP BY) !============================================================================================================================================
=> COUNT(*) / COUNT(col): Returns the number of rows (or non-NULL values in a column). Example: SELECT COUNT(*) FROM Users;
=> SUM(col): Returns the total sum of values in the column. Example: SELECT SUM(Price) FROM Orders;
=> AVG(col): Returns the average value of the column. Example: SELECT AVG(Rating) FROM Cinema;
=> MAX(col): Returns the maximum value in the column. Example: SELECT MAX(Rating) FROM Cinema;
=> MIN(col): Returns the minimum value in the column. Example: SELECT MIN(Rating) FROM Cinema;

==================================================================================================================! MySQL Conditional Functions !============================================================================================================================================
=> CASE (Expression): The full conditional structure for complex logic. Example: CASE WHEN price > 100 THEN 'Expensive' ELSE 'Cheap' END
=> IF(condition, val_true, val_false): A simpler inline conditional (MySQL specific). Example: SELECT IF(id % 2 = 0, 'Even', 'Odd') FROM Cinema;
=> IFNULL(a, b): Returns a if it is not NULL, otherwise returns b. Example: SELECT IFNULL(NullableName, 'N/A');
=> COALESCE(expression1, expression2, expression3, ...): It evaluates its arguments in order and returns the first argument that is not NULL.
  -> Example: COALESCE(ROUND( SUM(P.price * U.units) / SUM(U.units), 2),0.00) 
  -> The function first tries to return the result of the entire ROUND(...) expression.
  -> If the ROUND(...) expression evaluates to NULL (which could happen if, for example, a product was somehow included in the GROUP BY but had no associated units, leading to a division by zero that evaluates to NULL), then COALESCE skips this argument.
  -> It then returns the second argument, 0.00, ensuring the final average price for that product is reported as zero
